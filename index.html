<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Complex Snake Game</title>
<style>
  body {
    margin: 0;
    background: #000;
    font-family: Arial, sans-serif;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #gameCanvas {
    border: 4px solid #fff;
    display: block;
    margin-top: 20px;
  }
  #uiOverlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }
  #menu, #pauseScreen, #gameOverScreen {
    background: rgba(0,0,0,0.8);
    padding: 20px;
    border-radius: 10px;
    color: #fff;
    font-size: 24px;
    text-align: center;
    pointer-events: auto;
  }
  button {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 20px;
    cursor: pointer;
  }
</style>
</head>
<body>

<!-- Canvas for game rendering -->
<canvas id="gameCanvas" width="800" height="600"></canvas>

<!-- UI overlays for menus, game over, pause -->
<div id="uiOverlay">
  <div id="menu">
    <h2>Snake Game</h2>
    <button id="startBtn">Start Game</button>
    <button id="settingsBtn">Settings</button>
  </div>
  <div id="pauseScreen" style="display:none;">
    <h2>Paused</h2>
    <button id="resumeBtn">Resume</button>
    <button id="mainMenuBtn">Main Menu</button>
  </div>
  <div id="gameOverScreen" style="display:none;">
    <h2>Game Over</h2>
    <p id="finalScore"></p>
    <button id="restartBtn">Restart</button>
    <button id="mainMenuBtn2">Main Menu</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI Elements
const menuScreen = document.getElementById('menu');
const pauseScreen = document.getElementById('pauseScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const startBtn = document.getElementById('startBtn');
const resumeBtn = document.getElementById('resumeBtn');
const restartBtn = document.getElementById('restartBtn');
const mainMenuBtn = document.querySelectorAll('#mainMenuBtn, #mainMenuBtn2');
const finalScoreText = document.getElementById('finalScore');

let gameState = {
  running: false,
  paused: false,
  gameOver: false,
  level: 1,
  score: 0,
  highScores: [],
  // Add more properties for complexity
};

/* Game parameters - can be customized or loaded from options */
const configs = {
  width: 800,
  height: 600,
  gridSize: 20,
  initialSpeed: 150,
  speedIncrement: 10,
  maxSpeed: 50,
  levelData: [], // Placeholder for level layouts
  obstacles: [], // Obstacles position array
  powerUps: [], // Power-up position array
  skins: {
    snakeColor: '#0f0',
    foodColor: '#f00',
    backgroundColor: '#111',
  }
};

/* Snake object with properties and methods */
class Snake {
  constructor() {
    this.segments = [{x: 10, y: 10}]; // Starting position
    this.direction = {x: 1, y: 0}; // Moving right initially
    this.length = 1;
    this.color = configs.skins.snakeColor;
    // Add more properties for detailed body parts, animations, etc.
  }

  move() {
    // Calculate new head position
    const head = {x: this.segments[0].x + this.direction.x, y: this.segments[0].y + this.direction.y};
    // Check collision with walls, obstacles, self, etc.
    // Handle growth
    this.segments.unshift(head);
    if (this.segments.length > this.length) {
      this.segments.pop();
    }
  }

  grow() {
    this.length++;
  }

  setDirection(dx, dy) {
    // Prevent reverse direction
    if (-dx === this.direction.x && -dy === this.direction.y) return;
    this.direction = {x: dx, y: dy};
  }

  draw() {
    ctx.fillStyle = this.color;
    for (let segment of this.segments) {
      ctx.fillRect(segment.x * configs.gridSize, segment.y * configs.gridSize, configs.gridSize, configs.gridSize);
    }
  }
}

/* Game objects for food, obstacles, power-ups, etc. */
class Food {
  constructor() {
    this.position = {x: 0, y: 0};
    this.color = configs.skins.foodColor;
  }

  spawn() {
    // Random position not on snake or obstacles
    // Implement collision check
    this.position.x = Math.floor(Math.random() * (configs.width / configs.gridSize));
    this.position.y = Math.floor(Math.random() * (configs.height / configs.gridSize));
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc((this.position.x + 0.5) * configs.gridSize, (this.position.y + 0.5) * configs.gridSize, configs.gridSize/2, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* Initialize game objects */
let snake = new Snake();
let food = new Food();

function initGame() {
  // Reset game variables
  snake = new Snake();
  food.spawn();
  gameState.score = 0;
  gameState.level = 1;
  gameState.gameOver = false;
  gameState.paused = false;
  // Reset obstacles, power-ups, etc.
  // Load level data
  hideAllScreens();
  startGameLoop();
}

function hideAllScreens() {
  menuScreen.style.display = 'none';
  pauseScreen.style.display = 'none';
  gameOverScreen.style.display = 'none';
}

// Game Loop
let gameIntervalId = null;
function startGameLoop() {
  if (gameIntervalId) clearInterval(gameIntervalId);
  const speed = Math.max(configs.initialSpeed - (gameState.level - 1) * configs.speedIncrement, configs.maxSpeed);
  gameIntervalId = setInterval(update, speed);
}

// Update game state
function update() {
  if (gameState.paused || gameState.gameOver) return;

  snake.move();

  // Check collisions with walls
  const head = snake.segments[0];
  if (head.x < 0 || head.x >= configs.width / configs.gridSize || head.y < 0 || head.y >= configs.height / configs.gridSize) {
    endGame();
    return;
  }

  // Check collisions with self
  for (let i=1; i<snake.segments.length; i++) {
    if (snake.segments[i].x === head.x && snake.segments[i].y === head.y) {
      endGame();
      return;
    }
  }

  // Check collisions with obstacles
  // if obstacles array exists

  // Check food
  if (head.x === food.position.x && head.y === food.position.y) {
    snake.grow();
    gameState.score++;
    // Possibly spawn power-ups or obstacles here
    food.spawn();
    // Increase level or speed
    if (gameState.score % 10 === 0) {
      gameState.level++;
      startGameLoop();
    }
  }

  draw();
}

// Drawing everything
function draw() {
  ctx.fillStyle = configs.skins.backgroundColor;
  ctx.fillRect(0, 0, configs.width, configs.height);
  
  // Draw obstacles
  // for (let obs of obstacles) { ... }

  snake.draw();
  food.draw();

  // Draw UI info
  ctx.fillStyle = '#fff';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${gameState.score}`, 20, 30);
  ctx.fillText(`Level: ${gameState.level}`, 20, 55);
}

// Handle game over
function endGame() {
  clearInterval(gameIntervalId);
  gameState.gameOver = true;
  showGameOverScreen();
}

// UI controls
document.getElementById('startBtn').onclick = () => {
  initGame();
};
document.getElementById('restartBtn').onclick = () => {
  initGame();
};
document.getElementById('resumeBtn').onclick = () => {
  gameState.paused = false;
  startGameLoop();
  hideAllScreens();
};
document.querySelectorAll('#mainMenuBtn, #mainMenuBtn2').forEach(btn => {
  btn.onclick = () => {
    showMenu();
  };
});

function showMenu() {
  hideAllScreens();
  menuScreen.style.display = 'block';
}
function showGameOverScreen() {
  document.getElementById('finalScore').textContent = 'Final Score: ' + gameState.score;
  gameOverScreen.style.display = 'block';
}
function hideAllScreens() {
  menuScreen.style.display = 'none';
  pauseScreen.style.display = 'none';
  gameOverScreen.style.display = 'none';
}

// Controls
document.addEventListener('keydown', e => {
  if (gameState.gameOver) return;
  if (e.key === 'ArrowUp') snake.setDirection(0, -1);
  if (e.key === 'ArrowDown') snake.setDirection(0, 1);
  if (e.key === 'ArrowLeft') snake.setDirection(-1, 0);
  if (e.key === 'ArrowRight') snake.setDirection(1, 0);
  if (e.key === 'p') {
    gameState.paused = !gameState.paused;
    if (!gameState.paused) startGameLoop();
  }
});

// Start with menu
showMenu();

</script>
</body>
</html>
