<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Futuristic Connect 5 vs Robot</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    font-family: 'Orbitron', 'Arial', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
    min-height: 100vh;
    color: #fff;
  }

  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

  h1 {
    margin-top: 20px;
    font-size: 2.5em;
    letter-spacing: 2px;
    color: #00ffe8;
    text-shadow: 0 0 10px #00ffe8, 0 0 20px #00ffe8;
  }

  #gameContainer {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #gameCanvas {
    background: #111;
    border: 8px solid #00ffe8;
    border-radius: 20px;
    box-shadow: 0 0 30px #00ffe8 inset, 0 0 10px #00ffe8;
    transition: box-shadow 0.3s, border-color 0.3s;
  }

  #status {
    margin-top: 15px;
    font-size: 1.8em;
    text-shadow: 0 0 10px #fff, 0 0 20px #0ff;
  }

  /* Difficulty controls styling */
  #difficultyContainer {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #difficultyContainer label {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2em;
  }
  #difficultySelect {
    margin-top: 10px;
    padding: 8px;
    font-family: 'Orbitron', sans-serif;
    font-size: 1em;
  }
  #difficultyBarContainer {
    width: 300px;
    height: 20px;
    background-color: #555;
    margin-top: 10px;
    border-radius: 10px;
    overflow: hidden;
  }
  #difficultyBar {
    height: 100%;
    width: 33%;
    background-color: green;
    transition: width 0.3s, background-color 0.3s;
  }

  #rpsChoices {
    display: none;
    margin-top: 20px;
    gap: 20px;
    display: flex;
    justify-content: center;
  }

  .rpsButton {
    padding: 15px 30px;
    font-size: 1.5em;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    background: linear-gradient(45deg, #00ffe8, #0077ff);
    box-shadow: 0 0 20px #00ffe8, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  .rpsButton:hover {
    box-shadow: 0 0 30px #00ffe8, inset 0 0 15px #fff;
    transform: scale(1.1);
  }

  #controls {
    margin-top: 30px;
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
  }

  button {
    padding: 15px 25px;
    font-size: 1.4em;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    background: linear-gradient(45deg, #ff00cc, #3333ff);
    box-shadow: 0 0 20px #ff00cc, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  button:hover {
    box-shadow: 0 0 30px #ff00cc, inset 0 0 15px #fff;
    transform: scale(1.05);
  }
</style>
<!-- Load Orbitron font for a futuristic look -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
</head>
<body>

<h1>Futuristic Connect 5 vs Robot</h1>

<!-- Difficulty Controls -->
<div id="difficultyContainer">
  <label for="difficultySelect">Select Difficulty:</label>
  <select id="difficultySelect">
    <option value="easy">Easy</option>
    <option value="medium">Medium</option>
    <option value="hard">Hard</option>
  </select>
  <div id="difficultyBarContainer">
    <div id="difficultyBar"></div>
  </div>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas" width="500" height="500"></canvas>
  <div id="status">Click "Start Game" to begin</div>
  <div id="rpsChoices">
    <button class="rpsButton" data-choice="Rock">Rock</button>
    <button class="rpsButton" data-choice="Paper">Paper</button>
    <button class="rpsButton" data-choice="Scissors">Scissors</button>
  </div>
  <div id="gameControls" style="margin-top:20px;">
    <button id="startBtn">Start Game</button>
    <button id="restartBtn" disabled>Restart</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const rpsDiv = document.getElementById('rpsChoices');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

const rpsButtons = document.querySelectorAll('.rpsButton');

const difficultySelect = document.getElementById('difficultySelect');
const difficultyBar = document.getElementById('difficultyBar');

// --- Game State ---
let game = {
  size: 100,
  width: 5,
  height: 5,
  grid: [],
  currentPlayer: 'X', // human always X
  gameActive: false,
  connectToWin: 5,
  turnState: 'RPS', // 'RPS' or 'PLACING'
  lastRPSChoice: null,
  currentRPSChoice: null,
  winnerOfRPS: null,
  gameOver: false
};

// --- Difficulty Variables ---
let currentDifficulty = 'easy';

// Function to update difficulty bar appearance
function updateDifficultyBar() {
  let widthPercent;
  let color;
  switch (currentDifficulty) {
    case 'easy':
      widthPercent = 33;
      color = 'green';
      break;
    case 'medium':
      widthPercent = 66;
      color = 'orange';
      break;
    case 'hard':
      widthPercent = 100;
      color = 'red';
      break;
  }
  difficultyBar.style.width = widthPercent + '%';
  difficultyBar.style.backgroundColor = color;
}

// Listen for difficulty change
difficultySelect.addEventListener('change', () => {
  currentDifficulty = difficultySelect.value;
  updateDifficultyBar();
});

// Initialize bar
updateDifficultyBar();

// --- Grid Functions ---
function initGrid() {
  game.grid = [];
  for (let r=0; r<game.height; r++) {
    const row = [];
    for (let c=0; c<game.width; c++) {
      row.push('');
    }
    game.grid.push(row);
  }
}

// Draw functions
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  // Draw grid lines
  for (let i=1; i<game.width; i++) {
    ctx.beginPath();
    ctx.moveTo(i * game.size, 0);
    ctx.lineTo(i * game.size, canvas.height);
    ctx.stroke();
  }
  for (let j=1; j<game.height; j++) {
    ctx.beginPath();
    ctx.moveTo(0, j * game.size);
    ctx.lineTo(canvas.width, j * game.size);
    ctx.stroke();
  }
  // Draw pieces
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === 'X') {
        drawX(c * game.size, r * game.size);
      } else if (game.grid[r][c] === 'O') {
        drawO(c * game.size, r * game.size);
      }
    }
  }
}

function drawX(x, y) {
  ctx.strokeStyle = '#FF4136';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + 10, y + 10);
  ctx.lineTo(x + game.size - 10, y + game.size - 10);
  ctx.moveTo(x + game.size - 10, y + 10);
  ctx.lineTo(x + 10, y + game.size - 10);
  ctx.stroke();
}

function drawO(x, y) {
  ctx.strokeStyle = '#0074D9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x + game.size/2, y + game.size/2, game.size/2 - 10, 0, Math.PI * 2);
  ctx.stroke();
}

// --- Event Listeners ---
canvas.addEventListener('click', handleCanvasClick);
document.getElementById('startBtn').onclick = () => startGame();
document.getElementById('restartBtn').onclick = () => startGame();

// --- Game Control ---
function startGame() {
  initGrid();
  game.currentPlayer = 'X';
  game.gameActive = true;
  game.gameOver = false;
  game.turnState = 'RPS';
  game.lastRPSChoice = null;
  game.winnerOfRPS = null;
  statusDiv.textContent = "Choose Rock, Paper, or Scissors.";
  showRPSChoices();
  document.getElementById('restartBtn').disabled = false;
  draw();
}

// Show/hide RPS choices
function showRPSChoices() { rpsDiv.style.display = 'flex'; }
function hideRPSChoices() { rpsDiv.style.display = 'none'; }

// RPS button handlers
rpsButtons.forEach(btn => {
  btn.onclick = () => {
    if (game.gameOver || game.turnState !== 'RPS') return;
    game.currentRPSChoice = btn.getAttribute('data-choice');
    handleRPSResult();
  };
});

// --- RPS Logic ---
function handleRPSResult() {
  const choices = ['Rock','Paper','Scissors'];
  const robotChoice = choices[Math.floor(Math.random() * choices.length)];
  alert(`You chose ${game.currentRPSChoice}. Robot chose ${robotChoice}.`);
  const winner = determineRPSWinner(game.currentRPSChoice, robotChoice);
  if (!winner) {
    alert("It's a tie! Choose again.");
    showRPSChoices();
    return;
  }

  game.winnerOfRPS = winner;
  game.currentRPSChoice = null;

  if (winner === 'X') {
    // Human won RPS
    game.turnState = 'PLACING';
    statusDiv.textContent = "You won RPS! Place your X.";
    showRPSChoices(); // optional
  } else {
    // Robot won RPS
    robotPlaceMark();
  }
}

function determineRPSWinner(c1, c2) {
  if (c1 === c2) return null;
  if (
    (c1 === 'Rock' && c2 === 'Scissors') ||
    (c1 === 'Scissors' && c2 === 'Paper') ||
    (c1 === 'Paper' && c2 === 'Rock')
  ) {
    return 'X';
  } else {
    return 'O';
  }
}

// --- Human Placement ---
function handleCanvasClick(e) {
  if (game.gameOver || game.turnState !== 'PLACING') return;
  if (game.currentPlayer !== 'X') return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const row = Math.floor(y / game.size);
  const col = Math.floor(x / game.size);

  if (
    row >= 0 && row < game.height &&
    col >= 0 && col < game.width &&
    game.grid[row][col] === ''
  ) {
    game.grid[row][col] = 'X';
    if (checkWin(row, col, 'X')) {
      game.gameOver = true;
      game.gameActive = false;
      statusDiv.textContent = "Congratulations! You won!";
      draw();
      return;
    }
    if (checkDraw()) {
      game.gameOver = true;
      game.gameActive = false;
      statusDiv.textContent = "It's a draw!";
      draw();
      return;
    }
    // Next RPS turn
    game.turnState = 'RPS';
    showRPSChoices();
    updateStatus();
    draw();
  }
}

// --- AI Logic with Variable Difficulty ---
function robotRPS() {
  if (game.gameOver || game.turnState !== 'RPS') return;
  const choices = ['Rock','Paper','Scissors'];
  const choice = choices[Math.floor(Math.random() * choices.length)];
  alert(`Robot chooses ${choice} for RPS.`);
  const humanChoice = game.currentRPSChoice;
  const winner = determineRPSWinner(humanChoice, choice);
  if (!winner) {
    alert("It's a tie! RPS again.");
    showRPSChoices();
    return;
  }
  game.winnerOfRPS = winner;
  game.currentRPSChoice = null;

  if (winner === 'O') {
    // Robot wins RPS
    robotPlaceMark();
  } else {
    // Human wins RPS
    alert("Your turn to place X");
    game.turnState = 'PLACING';
    showRPSChoices();
  }
}

// --- Robot Places O with Difficulty-Based Logic ---
function robotPlaceMark() {
  const emptyCells = [];
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === '') {
        emptyCells.push({r, c});
      }
    }
  }
  if (emptyCells.length === 0) {
    game.gameOver = true;
    game.gameActive = false;
    statusDiv.textContent = "It's a draw!";
    draw();
    return;
  }

  let choice;

  if (currentDifficulty === 'easy') {
    // Random move
    choice = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  } else if (currentDifficulty === 'medium') {
    choice = getBestMoveMedium();
  } else if (currentDifficulty === 'hard') {
    choice = getBestMoveHard();
  }

  game.grid[choice.r][choice.c] = 'O';

  if (checkWin(choice.r, choice.c, 'O')) {
    game.gameOver = true;
    game.gameActive = false;
    statusDiv.textContent = "Robot wins!";
    draw();
    return;
  }

  if (checkDraw()) {
    game.gameOver = true;
    game.gameActive = false;
    statusDiv.textContent = "It's a draw!";
    draw();
    return;
  }

  // Next turn: human RPS
  alert("Your turn to choose RPS.");
  game.turnState = 'RPS';
  showRPSChoices();
  game.currentRPSChoice = null;
  updateStatus();
  draw();
}

// --- Heuristic for Medium ---
function getBestMoveMedium() {
  // 1. Try to win
  for (let cell of getEmptyCells()) {
    game.grid[cell.r][cell.c] = 'O';
    if (checkWin(cell.r, cell.c, 'O')) {
      game.grid[cell.r][cell.c] = '';
      return cell;
    }
    game.grid[cell.r][cell.c] = '';
  }
  // 2. Block opponent
  for (let cell of getEmptyCells()) {
    game.grid[cell.r][cell.c] = 'X';
    if (checkWin(cell.r, cell.c, 'X')) {
      game.grid[cell.r][cell.c] = '';
      return cell; // block human
    }
    game.grid[cell.r][cell.c] = '';
  }
  // 3. Else pick random
  const empty = getEmptyCells();
  return empty[Math.floor(Math.random() * empty.length)];
}

// --- Placeholder for Hard --- (for now, same as medium) ---
function getBestMoveHard() {
  // For demonstration, same as medium.
  // For actual AI: Implement Minimax or advanced heuristic here.
  return getBestMoveMedium();
}

// Helper to get list of empty cells
function getEmptyCells() {
  const cells = [];
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === '') {
        cells.push({r, c});
      }
    }
  }
  return cells;
}

// --- Win and Draw Checks ---
function checkWin(row, col, player) {
  const directions = [
    { dr:1, dc:0 }, { dr:0, dc:1 }, { dr:1, dc:1 }, { dr:1, dc:-1 }
  ];
  for (const d of directions) {
    let count = 1;
    let r = row + d.dr;
    let c = col + d.dc;
    while (
      r >= 0 && r < game.height &&
      c >= 0 && c < game.width &&
      game.grid[r][c] === player
    ) {
      count++;
      r += d.dr;
      c += d.dc;
    }
    r = row - d.dr;
    c = col - d.dc;
    while (
      r >= 0 && r < game.height &&
      c >= 0 && c < game.width &&
      game.grid[r][c] === player
    ) {
      count++;
      r -= d.dr;
      c -= d.dc;
    }
    if (count >= game.connectToWin) return true;
  }
  return false;
}

function checkDraw() {
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === '') return false;
    }
  }
  return true;
}

// --- UI Event Handlers ---
startBtn.onclick = () => startGame();

function startGame() {
  initGrid();
  game.currentPlayer = 'X';
  game.gameActive = true;
  game.gameOver = false;
  game.turnState = 'RPS';
  game.lastRPSChoice = null;
  game.winnerOfRPS = null;
  statusDiv.textContent = "Choose Rock, Paper, or Scissors.";
  showRPSChoices();
  document.getElementById('restartBtn').disabled = false;
  draw();
}

// --- Additional: Automatic robot RPS move ---
function autoRobotRPS() {
  if (game.gameOver || game.turnState !== 'RPS') return;
  const choices = ['Rock','Paper','Scissors'];
  const choice = choices[Math.floor(Math.random() * choices.length)];
  alert(`Robot chooses ${choice} for RPS.`);
  const humanChoice = game.currentRPSChoice;
  const winner = determineRPSWinner(humanChoice, choice);
  if (!winner) {
    alert("It's a tie! RPS again.");
    showRPSChoices();
    return;
  }
  game.winnerOfRPS = winner;
  game.currentRPSChoice = null;

  if (winner === 'O') {
    robotPlaceMark();
  } else {
    alert("Your turn to place X");
    game.turnState = 'PLACING';
    showRPSChoices();
  }
}

// --- Automatically trigger robot RPS after human move ---
function checkAndTriggerRobot() {
  if (game.turnState === 'RPS') {
    // For simplicity, auto-trigger RPS for robot
    setTimeout(() => {
      autoRobotRPS();
    }, 500);
  }
}

// Call this after human move
// inside handleCanvasClick, add:
function handleCanvasClick(e) {
  if (game.gameOver || game.turnState !== 'PLACING') return;
  if (game.currentPlayer !== 'X') return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const row = Math.floor(y / game.size);
  const col = Math.floor(x / game.size);

  if (
    row >= 0 && row < game.height &&
    col >= 0 && col < game.width &&
    game.grid[row][col] === ''
  ) {
    // Place X
    game.grid[row][col] = 'X';
    if (checkWin(row, col, 'X')) {
      game.gameOver = true;
      game.gameActive = false;
      statusDiv.textContent = "Congratulations! You won!";
      draw();
      return;
    }
    if (checkDraw()) {
      game.gameOver = true;
      game.gameActive = false;
      statusDiv.textContent = "It's a draw!";
      draw();
      return;
    }

    // After human move, trigger robot RPS if it's robot's turn
    if (game.turnState === 'RPS') {
      setTimeout(() => {
        autoRobotRPS();
      }, 500);
    }
    // Next RPS turn
    // (Already handled in autoRobotRPS)
  }
}

// --- Initialize ---
startBtn.onclick = () => startGame();
</script>
</body>
</html>
