<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Futuristic Connect 5 vs Robot</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    font-family: 'Orbitron', 'Arial', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
    min-height: 100vh;
    color: #fff;
  }
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

  h1 {
    margin-top: 20px;
    font-size: 2.5em;
    letter-spacing: 2px;
    color: #00ffe8;
    text-shadow: 0 0 10px #00ffe8, 0 0 20px #00ffe8;
  }

  #gameContainer {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #gameCanvas {
    background: #111;
    border: 8px solid #00ffe8;
    border-radius: 20px;
    box-shadow: 0 0 30px #00ffe8 inset, 0 0 10px #00ffe8;
    transition: box-shadow 0.3s, border-color 0.3s;
  }

  #status {
    margin-top: 15px;
    font-size: 1.8em;
    text-shadow: 0 0 10px #fff, 0 0 20px #0ff;
  }

  #rpsChoices {
    display: none;
    margin-top: 20px;
    gap: 20px;
    display: flex;
    justify-content: center;
  }

  .rpsButton {
    padding: 15px 30px;
    font-size: 1.5em;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    background: linear-gradient(45deg, #00ffe8, #0077ff);
    box-shadow: 0 0 20px #00ffe8, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  .rpsButton:hover {
    box-shadow: 0 0 30px #00ffe8, inset 0 0 15px #fff;
    transform: scale(1.1);
  }

  #controls {
    margin-top: 30px;
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
  }

  button {
    padding: 15px 25px;
    font-size: 1.4em;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    background: linear-gradient(45deg, #ff00cc, #3333ff);
    box-shadow: 0 0 20px #ff00cc, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  button:hover {
    box-shadow: 0 0 30px #ff00cc, inset 0 0 15px #fff;
    transform: scale(1.05);
  }
</style>
<!-- Load Orbitron font for a futuristic look -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
</head>
<body>

<h1>Futuristic Connect 5 vs Robot</h1>
<div id="gameContainer">
  <canvas id="gameCanvas" width="500" height="500"></canvas>
  <div id="status">Click "Start Game" to begin</div>
  <div id="rpsChoices">
    <button class="rpsButton" data-choice="Rock">Rock</button>
    <button class="rpsButton" data-choice="Paper">Paper</button>
    <button class="rpsButton" data-choice="Scissors">Scissors</button>
  </div>
  <div id="gameControls" style="margin-top:20px;">
    <button id="startBtn">Start Game</button>
    <button id="restartBtn" disabled>Restart</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const rpsDiv = document.getElementById('rpsChoices');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

const rpsButtons = document.querySelectorAll('.rpsButton');

let game = {
  size: 100,
  width: 5,
  height: 5,
  grid: [],
  currentPlayer: 'X', // human always X
  gameActive: false,
  connectToWin: 5,
  turnState: 'RPS', // 'RPS' or 'PLACING'
  lastMove: null,
  lastRPSChoice: null,
  currentRPSChoice: null,
  winnerOfRPS: null
};

// Initialize grid
function initGrid() {
  game.grid = [];
  for (let r=0; r<game.height; r++) {
    const row = [];
    for (let c=0; c<game.width; c++) {
      row.push('');
    }
    game.grid.push(row);
  }
}

// Draw grid and pieces
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  for (let i=1; i<game.width; i++) {
    ctx.beginPath();
    ctx.moveTo(i * game.size, 0);
    ctx.lineTo(i * game.size, canvas.height);
    ctx.stroke();
  }
  for (let j=1; j<game.height; j++) {
    ctx.beginPath();
    ctx.moveTo(0, j * game.size);
    ctx.lineTo(canvas.width, j * game.size);
    ctx.stroke();
  }
  // draw X and O
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      const cell = game.grid[r][c];
      if (cell === 'X') {
        drawX(c * game.size, r * game.size);
      } else if (cell === 'O') {
        drawO(c * game.size, r * game.size);
      }
    }
  }
}

function drawX(x, y) {
  ctx.strokeStyle = '#FF4136';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + 10, y + 10);
  ctx.lineTo(x + game.size - 10, y + game.size - 10);
  ctx.moveTo(x + game.size - 10, y + 10);
  ctx.lineTo(x + 10, y + game.size - 10);
  ctx.stroke();
}

function drawO(x, y) {
  ctx.strokeStyle = '#0074D9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x + game.size/2, y + game.size/2, game.size/2 - 10, 0, Math.PI * 2);
  ctx.stroke();
}

canvas.addEventListener('click', handleCanvasClick);
document.getElementById('startBtn').onclick = () => { startGame(); };
document.getElementById('restartBtn').onclick = () => { startGame(); };

// Start game
function startGame() {
  initGrid();
  game.currentPlayer = 'X'; // human always X
  game.gameActive = true;
  game.turnState = 'RPS';
  game.lastRPSChoice = null;
  game.winnerOfRPS = null;
  statusDiv.textContent = "Choose Rock, Paper, or Scissors.";
  showRPSChoices();
  document.getElementById('restartBtn').disabled = false;
  draw();
}

// Show/hide RPS choices
function showRPSChoices() { document.getElementById('rpsChoices').style.display = 'flex'; }
function hideRPSChoices() { document.getElementById('rpsChoices').style.display = 'none'; }

// RPS button handlers
document.querySelectorAll('.rpsButton').forEach(btn => {
  btn.onclick = () => {
    game.currentRPSChoice = btn.getAttribute('data-choice');
    handleRPSResult();
  };
});

// Handle RPS result: human chooses, robot responds
function handleRPSResult() {
  const choices = ['Rock','Paper','Scissors'];
  const robotChoice = choices[Math.floor(Math.random() * choices.length)];
  alert(`You chose ${game.currentRPSChoice}. Robot chose ${robotChoice}.`);
  const winner = determineRPSWinner(game.currentRPSChoice, robotChoice);
  if (!winner) {
    alert("It's a tie! Choose again.");
    showRPSChoices();
    return;
  }

  // Set who will place
  game.winnerOfRPS = winner;
  game.currentRPSChoice = null; // reset for next round

  if (winner === 'X') {
    // Human won RPS, set for placement
    game.currentPlayer = 'X';
    game.turnState = 'PLACING';
    alert("Your turn to place X");
    showRPSChoices(); // optional, can hide if you want
  } else {
    // Robot won RPS, place 'O' automatically
    robotPlaceMark();
  }
}

// Determine RPS winner
function determineRPSWinner(choice1, choice2) {
  if (choice1 === choice2) return null; // tie
  if (
    (choice1 === 'Rock' && choice2 === 'Scissors') ||
    (choice1 === 'Scissors' && choice2 === 'Paper') ||
    (choice1 === 'Paper' && choice2 === 'Rock')
  ) {
    return 'X'; // human
  } else {
    return 'O'; // robot
  }
}

// Handle human placement
function handleCanvasClick(e) {
  if (!game.gameActive || game.turnState !== 'PLACING') return;
  if (game.currentPlayer !== 'X') {
    alert("It's not your turn!");
    return;
  }
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const row = Math.floor(y / game.size);
  const col = Math.floor(x / game.size);
  if (row >= 0 && row < game.height && col >= 0 && col < game.width) {
    if (game.grid[row][col] === '') {
      game.grid[row][col] = 'X'; // human always X
      if (checkWin(row, col, 'X')) {
        game.gameActive = false;
        statusDiv.textContent = "You win!";
        draw();
        return;
      }
      if (checkDraw()) {
        game.gameActive = false;
        statusDiv.textContent = "It's a draw!";
        draw();
        return;
      }
      // After your placement, set state to 'RPS' for next turn
      game.currentPlayer = 'X'; // still human
      game.turnState = 'RPS'; // next round RPS
      showRPSChoices();
      updateStatus();
      draw();
    }
  }
}

// Robot plays RPS
function robotRPS() {
  const choices = ['Rock','Paper','Scissors'];
  const choice = choices[Math.floor(Math.random() * choices.length)];
  alert(`Robot chooses ${choice} for RPS.`);
  const humanChoice = game.currentRPSChoice;
  const winner = determineRPSWinner(humanChoice, choice);
  if (!winner) {
    alert("It's a tie! RPS again.");
    showRPSChoices();
    return;
  }

  // Set who will place
  game.winnerOfRPS = winner;
  game.currentRPSChoice = null; // reset for next round
  if (winner === 'O') {
    // Robot won RPS, place 'O' automatically
    robotPlaceMark();
  } else {
    // Human won RPS
    alert("Your turn to place X");
    game.currentPlayer = 'X'; // ensure human is X
    game.turnState = 'RPS'; // wait for next RPS input
    showRPSChoices();
  }
}

// Robot automatically places 'O'
function robotPlaceMark() {
  const emptyCells = [];
  for (let r = 0; r < game.height; r++) {
    for (let c = 0; c < game.width; c++) {
      if (game.grid[r][c] === '') {
        emptyCells.push({ r, c });
      }
    }
  }
  if (emptyCells.length === 0) {
    game.gameActive = false;
    statusDiv.textContent = "It's a draw!";
    draw();
    return;
  }
  const choice = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  game.grid[choice.r][choice.c] = 'O';

  if (checkWin(choice.r, choice.c, 'O')) {
    game.gameActive = false;
    statusDiv.textContent = "Robot wins!";
    draw();
    return;
  }
  if (checkDraw()) {
    game.gameActive = false;
    statusDiv.textContent = "It's a draw!";
    draw();
    return;
  }

  // Human's turn to choose RPS again
  alert("Your turn to choose RPS.");
  game.turnState = 'RPS';
  game.currentRPSChoice = null;
  showRPSChoices();
  // Switch back to human
  game.currentPlayer = 'X';
  updateStatus();
  draw();
}

// Check win condition
function checkWin(row, col, player) {
  const directions = [
    { dr: 1, dc: 0 },
    { dr: 0, dc: 1 },
    { dr: 1, dc: 1 },
    { dr: 1, dc: -1 }
  ];
  for (const d of directions) {
    let count = 1;
    let r = row + d.dr;
    let c = col + d.dc;
    while (r >= 0 && r < game.height && c >= 0 && c < game.width && game.grid[r][c] === player) {
      count++;
      r += d.dr;
      c += d.dc;
    }
    r = row - d.dr;
    c = col - d.dc;
    while (r >= 0 && r < game.height && c >= 0 && c < game.width && game.grid[r][c] === player) {
      count++;
      r -= d.dr;
      c -= d.dc;
    }
    if (count >= game.connectToWin) return true;
  }
  return false;
}

// Check for draw
function checkDraw() {
  for (let r = 0; r < game.height; r++) {
    for (let c = 0; c < game.width; c++) {
      if (game.grid[r][c] === '') return false;
    }
  }
  return true;
}
</script>
</body>
</html>
