<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Futuristic Connect 5 vs Robot</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    font-family: 'Orbitron', 'Arial', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
    min-height: 100vh;
    color: #fff;
  }

  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

  h1 {
    margin-top: 20px;
    font-size: 2.5em;
    letter-spacing: 2px;
    color: #00ffe8;
    text-shadow: 0 0 10px #00ffe8, 0 0 20px #00ffe8;
  }

  #gameContainer {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #gameCanvas {
    background: #111;
    border: 8px solid #00ffe8;
    border-radius: 20px;
    box-shadow: 0 0 30px #00ffe8 inset, 0 0 10px #00ffe8;
    transition: box-shadow 0.3s, border-color 0.3s;
  }

  #status {
    margin-top: 15px;
    font-size: 1.8em;
    text-shadow: 0 0 10px #fff, 0 0 20px #0ff;
  }

  /* Difficulty controls styling */
  #difficultyContainer {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #difficultyContainer label {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2em;
  }
  #difficultySelect {
    margin-top: 10px;
    padding: 8px;
    font-family: 'Orbitron', sans-serif;
    font-size: 1em;
  }
  #difficultyBarContainer {
    width: 300px;
    height: 20px;
    background-color: #555;
    margin-top: 10px;
    border-radius: 10px;
    overflow: hidden;
  }
  #difficultyBar {
    height: 100%;
    width: 33%;
    background-color: green;
    transition: width 0.3s, background-color 0.3s;
  }

  #rpsChoices {
    display: none;
    margin-top: 20px;
    gap: 20px;
    display: flex;
    justify-content: center;
  }

  .rpsButton {
    padding: 15px 30px;
    font-size: 1.5em;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    background: linear-gradient(45deg, #00ffe8, #0077ff);
    box-shadow: 0 0 20px #00ffe8, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  .rpsButton:hover {
    box-shadow: 0 0 30px #00ffe8, inset 0 0 15px #fff;
    transform: scale(1.1);
  }

  #controls {
    margin-top: 30px;
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
  }

  button {
    padding: 15px 25px;
    font-size: 1.4em;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    background: linear-gradient(45deg, #ff00cc, #3333ff);
    box-shadow: 0 0 20px #ff00cc, inset 0 0 10px #fff;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    transition: all 0.3s ease;
  }

  button:hover {
    box-shadow: 0 0 30px #ff00cc, inset 0 0 15px #fff;
    transform: scale(1.05);
  }

  /* Music toggle button style */
  #musicBtn {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 1.2em;
    border-radius: 10px;
    background: linear-gradient(45deg, #ffcc00, #ffaa00);
    box-shadow: 0 0 20px #ffcc00, inset 0 0 10px #fff;
    cursor: pointer;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    transition: all 0.3s ease;
  }
  #musicBtn:hover {
    box-shadow: 0 0 30px #ffcc00, inset 0 0 15px #fff;
    transform: scale(1.05);
  }
</style>
<!-- Load Orbitron font for a futuristic look -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
</head>
<body>

<h1>Futuristic Connect 5 vs Robot</h1>

<!-- Music toggle button -->
<button id="musicBtn">Music On</button>

<!-- Difficulty Controls -->
<div id="difficultyContainer">
  <label for="difficultySelect">Select Difficulty:</label>
  <select id="difficultySelect">
    <option value="easy">Easy</option>
    <option value="medium">Medium</option>
    <option value="hard">Hard</option>
  </select>
  <div id="difficultyBarContainer">
    <div id="difficultyBar"></div>
  </div>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas" width="500" height="500"></canvas>
  <div id="status">Click "Start Game" to begin</div>
  <div id="rpsChoices">
    <button class="rpsButton" data-choice="Rock">Rock</button>
    <button class="rpsButton" data-choice="Paper">Paper</button>
    <button class="rpsButton" data-choice="Scissors">Scissors</button>
  </div>
  <div id="gameControls" style="margin-top:20px;">
    <button id="startBtn">Start Game</button>
    <button id="restartBtn" disabled>Restart</button>
  </div>
</div>

<!-- Background Music -->
<audio id="backgroundMusic" loop>
  <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg" />
</audio>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const rpsDiv = document.getElementById('rpsChoices');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

const rpsButtons = document.querySelectorAll('.rpsButton');

const difficultySelect = document.getElementById('difficultySelect');
const difficultyBar = document.getElementById('difficultyBar');

const musicBtn = document.getElementById('musicBtn');
const backgroundMusic = document.getElementById('backgroundMusic');

let musicPlaying = false;

// --- Game State ---
let game = {
  size: 100,
  width: 5,
  height: 5,
  grid: [],
  currentPlayer: 'X', // human always X
  gameActive: false,
  connectToWin: 5,
  turnState: 'RPS', // 'RPS' or 'PLACING'
  lastRPSChoice: null,
  currentRPSChoice: null,
  winnerOfRPS: null,
  gameOver: false
};

// --- Difficulty Variables ---
let currentDifficulty = 'easy';

// Function to update difficulty bar appearance
function updateDifficultyBar() {
  let widthPercent;
  let color;
  switch (currentDifficulty) {
    case 'easy':
      widthPercent = 33;
      color = 'green';
      break;
    case 'medium':
      widthPercent = 66;
      color = 'orange';
      break;
    case 'hard':
      widthPercent = 100;
      color = 'red';
      break;
  }
  difficultyBar.style.width = widthPercent + '%';
  difficultyBar.style.backgroundColor = color;
}

// Listen for difficulty change
difficultySelect.addEventListener('change', () => {
  currentDifficulty = difficultySelect.value;
  updateDifficultyBar();
});

// Initialize bar
updateDifficultyBar();

// --- Grid Functions ---
function initGrid() {
  game.grid = [];
  for (let r=0; r<game.height; r++) {
    const row = [];
    for (let c=0; c<game.width; c++) {
      row.push('');
    }
    game.grid.push(row);
  }
}

// Draw functions
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  // Draw grid lines
  for (let i=1; i<game.width; i++) {
    ctx.beginPath();
    ctx.moveTo(i * game.size, 0);
    ctx.lineTo(i * game.size, canvas.height);
    ctx.stroke();
  }
  for (let j=1; j<game.height; j++) {
    ctx.beginPath();
    ctx.moveTo(0, j * game.size);
    ctx.lineTo(canvas.width, j * game.size);
    ctx.stroke();
  }
  // Draw pieces
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === 'X') {
        drawX(c * game.size, r * game.size);
      } else if (game.grid[r][c] === 'O') {
        drawO(c * game.size, r * game.size);
      }
    }
  }
}

function drawX(x, y) {
  ctx.strokeStyle = '#FF4136';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + 10, y + 10);
  ctx.lineTo(x + game.size - 10, y + game.size - 10);
  ctx.moveTo(x + 10, y + game.size - 10);
  ctx.lineTo(x + game.size - 10, y + 10);
  ctx.stroke();
}

function drawO(x, y) {
  ctx.strokeStyle = '#2ECC40';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x + game.size/2, y + game.size/2, game.size/2 - 10, 0, Math.PI*2);
  ctx.stroke();
}

// --- Game Logic ---
function checkWin(r, c, player) {
  const directions = [
    [0,1], [1,0], [1,1], [1,-1]
  ];
  for (const [dr, dc] of directions) {
    let count = 1;
    let rr = r + dr;
    let cc = c + dc;
    while (rr >= 0 && rr < game.height && cc >= 0 && cc < game.width && game.grid[rr][cc] === player) {
      count++;
      rr += dr;
      cc += dc;
    }
    rr = r - dr;
    cc = c - dc;
    while (rr >= 0 && rr < game.height && cc >= 0 && cc < game.width && game.grid[rr][cc] === player) {
      count++;
      rr -= dr;
      cc -= dc;
    }
    if (count >= game.connectToWin) return true;
  }
  return false;
}

function isBoardFull() {
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === '') return false;
    }
  }
  return true;
}

// --- RPS Logic ---
function robotChooseRPS() {
  const choices = ['Rock', 'Paper', 'Scissors'];
  return choices[Math.floor(Math.random() * 3)];
}

function showRPSChoices() {
  rpsDiv.style.display = 'flex';
}
function hideRPSChoices() {
  rpsDiv.style.display = 'none';
}
function getRPSWinner(humanChoice, robotChoice) {
  if (humanChoice === robotChoice) return 'tie';
  if (
    (humanChoice === 'Rock' && robotChoice === 'Scissors') ||
    (humanChoice === 'Paper' && robotChoice === 'Rock') ||
    (humanChoice === 'Scissors' && robotChoice === 'Paper')
  ) return 'X';
  return 'O';
}
function handleRPSResult() {
  const human = game.currentRPSChoice;
  const robot = robotChooseRPS();
  statusDiv.textContent = `Robot chose ${robot}. `;
  const winner = getRPSWinner(human, robot);
  if (winner === 'tie') {
    statusDiv.textContent += "It's a tie! Choose again.";
    showRPSChoices();
    return;
  }
  if (winner === 'X') {
    game.turnState = 'PLACING';
    statusDiv.textContent += "You won RPS! Place your X.";
    hideRPSChoices();
  } else {
    game.turnState = 'WAITING';
    hideRPSChoices();
    robotPlaceMark();
  }
}
function placeMark(r, c, player) {
  if (game.grid[r][c] !== '') return false;
  game.grid[r][c] = player;
  draw();
  if (checkWin(r, c, player)) {
    game.gameOver = true;
    statusDiv.textContent = (player === 'X' ? 'You' : 'Robot') + " won the game!";
    game.turnState = 'GAME_OVER';
    hideRPSChoices();
    restartBtn.disabled = false;
    return true;
  } else if (isBoardFull()) {
    game.gameOver = true;
    statusDiv.textContent = "It's a draw!";
    game.turnState = 'GAME_OVER';
    hideRPSChoices();
    restartBtn.disabled = false;
    return true;
  }
  return false;
}
function robotPlaceMark() {
  if (game.gameOver) return;
  const empties = [];
  for (let r=0; r<game.height; r++) {
    for (let c=0; c<game.width; c++) {
      if (game.grid[r][c] === '') empties.push([r,c]);
    }
  }
  if (empties.length === 0) return;
  let choice;
  if (currentDifficulty === 'easy') {
    choice = empties[Math.floor(Math.random() * empties.length)];
  } else if (currentDifficulty === 'medium') {
    if (Math.random() < 0.5) {
      choice = empties[Math.floor(Math.random() * empties.length)];
    } else {
      choice = empties[0];
    }
  } else {
    choice = empties[0];
  }
  placeMark(choice[0], choice[1], 'O');
  if (!game.gameOver) {
    game.turnState = 'RPS';
    statusDiv.textContent = "Your turn to choose Rock, Paper, or Scissors.";
    showRPSChoices();
  }
  restartBtn.disabled = false;
}

// --- Event Listeners ---

canvas.addEventListener('click', (e) => {
  if (game.turnState !== 'PLACING' || game.gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const col = Math.floor(x / game.size);
  const row = Math.floor(y / game.size);
  if (placeMark(row, col, 'X')) {
    return;
  }
  game.turnState = 'RPS';
  statusDiv.textContent = "Robot's turn to choose Rock, Paper, or Scissors.";
  showRPSChoices();
});

rpsButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (game.turnState !== 'RPS' || game.gameOver) return;
    game.currentRPSChoice = btn.getAttribute('data-choice');
    hideRPSChoices();
    handleRPSResult();
  });
});

startBtn.addEventListener('click', () => {
  startGame();
});
restartBtn.addEventListener('click', () => {
  startGame();
});
// --- Music toggle ---
document.getElementById('musicBtn').addEventListener('click', () => {
  if (!musicPlaying) {
    backgroundMusic.play();
    musicPlaying = true;
    musicBtn.textContent = 'Music Off';
  } else {
    backgroundMusic.pause();
    musicPlaying = false;
    musicBtn.textContent = 'Music On';
  }
});

// --- Start game function ---
function startGame() {
  initGrid();
  draw();
  game.gameActive = true;
  game.gameOver = false;
  game.turnState = 'RPS';
  statusDiv.textContent = "Choose Rock, Paper, or Scissors to start.";
  showRPSChoices();
  restartBtn.disabled = true;
}

// --- Initialize ---
initGrid();
draw();
statusDiv.textContent = 'Click "Start Game" to begin.';
hideRPSChoices();
restartBtn.disabled = true;
</script>

</body>
</html>
