<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Complex Tic Tac Toe</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #222, #555);
    font-family: 'Arial', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: start;
    height: 100vh;
    color: #fff;
  }

  h1 {
    margin-top: 20px;
  }

  #gameContainer {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Canvas for game */
  #gameCanvas {
    background: #111;
    border: 8px solid #4CAF50;
    border-radius: 12px;
    box-shadow: 0 0 20px #4CAF50 inset;
  }

  /* Controls & info */
  #controls {
    margin-top: 20px;
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
  }

  button {
    padding: 12px 24px;
    font-size: 1.2em;
    border: none;
    border-radius: 8px;
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  button:hover {
    background-color: #45a049;
  }

  /* Theme selector */
  #themeSelector {
    padding: 10px;
    font-size: 1em;
  }

  /* Info display */
  #status {
    margin-top: 20px;
    font-size: 1.4em;
  }

  /* Additional UI for stats, leaderboard, etc., can be added here */

</style>
</head>
<body>

<h1>Ultimate Tic Tac Toe</h1>
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="800"></canvas>
  <div id="controls">
    <button id="restartBtn">Restart</button>
    <button id="undoBtn">Undo</button>
    <button id="aiBtn">Play vs AI</button>
    <button id="themeBtn">Change Theme</button>
  </div>
  <div id="status">Your turn!</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const statusDiv = document.getElementById('status');
const restartBtn = document.getElementById('restartBtn');
const undoBtn = document.getElementById('undoBtn');
const aiBtn = document.getElementById('aiBtn');
const themeBtn = document.getElementById('themeBtn');

let gameState = {
  boardSize: 3,
  cellSize: 250,
  grid: [], // 2D array
  currentPlayer: 'X',
  gameActive: true,
  moveHistory: [],
  vsAI: false,
  themeIndex: 0,
  themes: [
    { background: '#111', lineColor: '#4CAF50', xColor: '#f00', oColor: '#00f' },
    { background: '#222', lineColor: '#ffeb3b', xColor: '#e91e63', oColor: '#00bcd4' },
    { background: '#000', lineColor: '#fff', xColor: '#fff', oColor: '#ccc' }
  ],
  aiThinking: false
};

// Initialize board
function initBoard() {
  gameState.grid = [];
  for (let i=0; i<gameState.boardSize; i++) {
    gameState.grid.push(new Array(gameState.boardSize).fill(''));
  }
  gameState.moveHistory = [];
  gameState.currentPlayer = 'X';
  gameState.gameActive = true;
  draw();
}

function draw() {
  const theme = gameState.themes[gameState.themeIndex];
  ctx.fillStyle = theme.background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw grid lines
  ctx.strokeStyle = theme.lineColor;
  ctx.lineWidth = 4;
  for (let i=1; i<gameState.boardSize; i++) {
    ctx.beginPath();
    ctx.moveTo(i * gameState.cellSize, 0);
    ctx.lineTo(i * gameState.cellSize, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, i * gameState.cellSize);
    ctx.lineTo(canvas.width, i * gameState.cellSize);
    ctx.stroke();
  }

  // Draw X and O
  for (let r=0; r<gameState.boardSize; r++) {
    for (let c=0; c<gameState.boardSize; c++) {
      const cell = gameState.grid[r][c];
      const x = c * gameState.cellSize;
      const y = r * gameState.cellSize;

      if (cell === 'X') {
        drawX(x, y);
      } else if (cell === 'O') {
        drawO(x, y);
      }
    }
  }
}

function drawX(x, y) {
  const theme = gameState.themes[gameState.themeIndex];
  ctx.strokeStyle = theme.xColor;
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(x + 20, y + 20);
  ctx.lineTo(x + gameState.cellSize - 20, y + gameState.cellSize - 20);
  ctx.moveTo(x + gameState.cellSize - 20, y + 20);
  ctx.lineTo(x + 20, y + gameState.cellSize - 20);
  ctx.stroke();
}

function drawO(x, y) {
  const theme = gameState.themes[gameState.themeIndex];
  ctx.strokeStyle = theme.oColor;
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(x + gameState.cellSize/2, y + gameState.cellSize/2, gameState.cellSize/2 - 20, 0, Math.PI * 2);
  ctx.stroke();
}

canvas.addEventListener('click', handleCanvasClick);
document.getElementById('restartBtn').onclick = () => { initBoard(); };
document.getElementById('undoBtn').onclick = undoMove;
document.getElementById('aiBtn').onclick = toggleAI;
document.getElementById('themeBtn').onclick = changeTheme;

function handleCanvasClick(e) {
  if (!gameState.gameActive || gameState.aiThinking) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const row = Math.floor(y / gameState.cellSize);
  const col = Math.floor(x / gameState.cellSize);
  if (row >= 0 && row < gameState.boardSize && col >= 0 && col < gameState.boardSize) {
    if (gameState.grid[row][col] === '') {
      makeMove(row, col);
      if (gameState.vsAI && gameState.currentPlayer === 'O') {
        aiMove();
      }
    }
  }
}

function makeMove(row, col) {
  if (gameState.grid[row][col] !== '' || !gameState.gameActive) return;
  gameState.grid[row][col] = gameState.currentPlayer;
  gameState.moveHistory.push({row, col, player: gameState.currentPlayer});
  if (checkWin(row, col)) {
    gameOver(`${gameState.currentPlayer} wins!`);
  } else if (isDraw()) {
    gameOver("It's a draw!");
  } else {
    switchPlayer();
    updateStatus();
  }
  draw();
}

function switchPlayer() {
  gameState.currentPlayer = (gameState.currentPlayer === 'X') ? 'O' : 'X';
}

function updateStatus() {
  if (gameState.vsAI && gameState.currentPlayer === 'O' && !gameState.gameOver) {
    statusDiv.textContent = "AI is thinking...";
  } else {
    statusDiv.textContent = `Player ${gameState.currentPlayer}'s turn`;
  }
}

function checkWin(row, col) {
  const player = gameState.grid[row][col];
  const size = gameState.boardSize;
  // Check row
  if (gameState.grid[row].every(cell => cell === player)) return true;
  // Check column
  let colWin = true;
  for (let r=0; r<size; r++) {
    if (gameState.grid[r][col] !== player) {
      colWin = false;
      break;
    }
  }
  if (colWin) return true;
  // Check diagonals
  if (row === col) {
    let diag1 = true;
    for (let i=0; i<size; i++) {
      if (gameState.grid[i][i] !== player) {
        diag1 = false;
        break;
      }
    }
    if (diag1) return true;
  }
  if (row + col === size -1) {
    let diag2 = true;
    for (let i=0; i<size; i++) {
      if (gameState.grid[i][size - 1 - i] !== player) {
        diag2 = false;
        break;
      }
    }
    if (diag2) return true;
  }
  return false;
}

function isDraw() {
  for (let row of gameState.grid) {
    if (row.includes('')) return false;
  }
  return true;
}

function gameOver(message) {
  gameState.gameActive = false;
  statusDiv.textContent = message;
}

// Undo last move
function undoMove() {
  if (gameState.moveHistory.length === 0 || !gameState.gameActive) return;
  const lastMove = gameState.moveHistory.pop();
  gameState.grid[lastMove.row][lastMove.col] = '';
  gameState.currentPlayer = lastMove.player;
  updateStatus();
  draw();
}

// Toggle AI mode
function toggleAI() {
  gameState.vsAI = !gameState.vsAI;
  alert(`Playing vs AI: ${gameState.vsAI ? 'Yes' : 'No'}`);
}

// Change Theme
function changeTheme() {
  gameState.themeIndex = (gameState.themeIndex + 1) % gameState.themes.length;
  draw();
}

// AI move (simple random for demo, can implement Minimax for complexity)
async function aiMove() {
  gameState.aiThinking = true;
  updateStatus();
  // Simulate thinking delay
  await new Promise(r => setTimeout(r, 500));
  const emptyCells = [];
  for (let r=0; r<gameState.boardSize; r++) {
    for (let c=0; c<gameState.boardSize; c++) {
      if (gameState.grid[r][c] === '') {
        emptyCells.push({row: r, col: c});
      }
    }
  }
  if (emptyCells.length === 0) return;
  const choice = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  makeMove(choice.row, choice.col);
  gameState.aiThinking = false;
  updateStatus();
}

// Start game
initBoard();

</script>
</body>
</html>
